## 任务5:  多模块工程

在这个任务中，我们将学习如何处理多个模块文件直接的关系。

## 1. 分离模块的声明和实现

请打开路径./work5/implementation_unit/my_lib。

在该路径下有三个文件，`my_lib.cppm`文件中只有声明没有实现，`foo.cpp`实现了类foo。

### 任务：

请仿照`foo.cpp`文件，在`bar.cpp`文件中实现剩下的声明。

请使用命令`xmake build work5_1`生成程序，使用`xmake run work5_1`运行程序。

## 2. 组合多个模块

请打开路径./work5/interface_unit/my_lib/impl。

在该路径下有my_lib.foo和my_lib.bar两个模块。

### 任务1：

请在./work5/interface_unit/my_lib/my_lib.cppm中，将这两个模块组合为一个完整的my_lib模块。

完成任务以后，请使用命令`xmake build work5_2`生成程序，使用`xmake run work5_2`运行程序。

### 任务2：

请修改./work5/interface_unit/main2.cpp中，尝试只导入my_lib.foo模块，不导入my_lib.bar模块。

完成任务以后，请使用命令`xmake build work5_3`生成程序，使用`xmake run work5_3`运行程序。

## 3. 使用module partition

请打开路径./work5/partition_unit/my_lib。

在该路径下有"foo.cppm"，"bar.cppm"和"my_lib.cppm"三个模块文件。

### 任务1:

 请运行命令`xmake build work5_4`，应该会输出如下报错：

```shell
error: work5/partition_unit/my_lib/foo.cppm:7:11: error: declaration of 'foo' in module my_lib.foo follows declaration in module my_lib.bar
    7 |     class foo {
      |           ^
/home/user/workshop/work5/partition_unit/my_lib/bar.cppm:4:11: note: previous declaration is here
    4 |     class foo;
      |           ^
1 error generated.
  > in work5/partition_unit/my_lib/foo.cppm
```

这是因为在我们在模块my_lib.foo中导入了my_lib.bar，在my_lib.bar中使用了foo的前置声明。

在传统的头文件中，foo和bar会被一起include，包含在同一个代码单元（cpp文件）中，属于internal-linkage，C++标准允许同一个cpp文件中存在多个相同的指向同一个实体的声明。

然而，当我们将其改写为模块以后，foo和bar位于两个不同的代码单元（模块文件）中，因此编译器认为两个声明互相冲突了。

我们可以使用module partition解决这个问题。

#### 任务2：

请参考注释，修改"foo.cppm"，"bar.cppm"和"my_lib.cppm"三个模块文件。

将模块my_lib.foo改为partition模块my_lib:foo,将模块my_lib.bar改为partition模块my_lib:bar，并将其合成一个模块mylib。

请使用命令`xmake build work5_4`再次生成程序，使用`xmake run work5_4`运行程序。

#### 任务3：

完成任务1后，请修改文件main.cpp，尝试使用`import my_lib:foo`代替`import my_lib`，再次运行命令`xmake build work5_4`，观察能否编译成功？为什么？